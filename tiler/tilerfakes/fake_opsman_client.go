// Code generated by counterfeiter. DO NOT EDIT.
package tilerfakes

import (
	"context"
	"os"
	"sync"

	"github.com/starkandwayne/om-tiler/pattern"
	"github.com/starkandwayne/om-tiler/tiler"
)

type FakeOpsmanClient struct {
	ApplyChangesStub        func(context.Context) error
	applyChangesMutex       sync.RWMutex
	applyChangesArgsForCall []struct {
		arg1 context.Context
	}
	applyChangesReturns struct {
		result1 error
	}
	applyChangesReturnsOnCall map[int]struct {
		result1 error
	}
	ConfigureAuthenticationStub        func(context.Context) error
	configureAuthenticationMutex       sync.RWMutex
	configureAuthenticationArgsForCall []struct {
		arg1 context.Context
	}
	configureAuthenticationReturns struct {
		result1 error
	}
	configureAuthenticationReturnsOnCall map[int]struct {
		result1 error
	}
	ConfigureDirectorStub        func(context.Context, []byte) error
	configureDirectorMutex       sync.RWMutex
	configureDirectorArgsForCall []struct {
		arg1 context.Context
		arg2 []byte
	}
	configureDirectorReturns struct {
		result1 error
	}
	configureDirectorReturnsOnCall map[int]struct {
		result1 error
	}
	ConfigureProductStub        func(context.Context, []byte) error
	configureProductMutex       sync.RWMutex
	configureProductArgsForCall []struct {
		arg1 context.Context
		arg2 []byte
	}
	configureProductReturns struct {
		result1 error
	}
	configureProductReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteInstallationStub        func(context.Context) error
	deleteInstallationMutex       sync.RWMutex
	deleteInstallationArgsForCall []struct {
		arg1 context.Context
	}
	deleteInstallationReturns struct {
		result1 error
	}
	deleteInstallationReturnsOnCall map[int]struct {
		result1 error
	}
	FilesUploadedStub        func(context.Context, pattern.Tile) (bool, error)
	filesUploadedMutex       sync.RWMutex
	filesUploadedArgsForCall []struct {
		arg1 context.Context
		arg2 pattern.Tile
	}
	filesUploadedReturns struct {
		result1 bool
		result2 error
	}
	filesUploadedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	PollTillOnlineStub        func(context.Context) error
	pollTillOnlineMutex       sync.RWMutex
	pollTillOnlineArgsForCall []struct {
		arg1 context.Context
	}
	pollTillOnlineReturns struct {
		result1 error
	}
	pollTillOnlineReturnsOnCall map[int]struct {
		result1 error
	}
	StageProductStub        func(context.Context, pattern.Tile) error
	stageProductMutex       sync.RWMutex
	stageProductArgsForCall []struct {
		arg1 context.Context
		arg2 pattern.Tile
	}
	stageProductReturns struct {
		result1 error
	}
	stageProductReturnsOnCall map[int]struct {
		result1 error
	}
	UploadProductStub        func(context.Context, *os.File) error
	uploadProductMutex       sync.RWMutex
	uploadProductArgsForCall []struct {
		arg1 context.Context
		arg2 *os.File
	}
	uploadProductReturns struct {
		result1 error
	}
	uploadProductReturnsOnCall map[int]struct {
		result1 error
	}
	UploadStemcellStub        func(context.Context, *os.File) error
	uploadStemcellMutex       sync.RWMutex
	uploadStemcellArgsForCall []struct {
		arg1 context.Context
		arg2 *os.File
	}
	uploadStemcellReturns struct {
		result1 error
	}
	uploadStemcellReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeOpsmanClient) ApplyChanges(arg1 context.Context) error {
	fake.applyChangesMutex.Lock()
	ret, specificReturn := fake.applyChangesReturnsOnCall[len(fake.applyChangesArgsForCall)]
	fake.applyChangesArgsForCall = append(fake.applyChangesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("ApplyChanges", []interface{}{arg1})
	fake.applyChangesMutex.Unlock()
	if fake.ApplyChangesStub != nil {
		return fake.ApplyChangesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.applyChangesReturns
	return fakeReturns.result1
}

func (fake *FakeOpsmanClient) ApplyChangesCallCount() int {
	fake.applyChangesMutex.RLock()
	defer fake.applyChangesMutex.RUnlock()
	return len(fake.applyChangesArgsForCall)
}

func (fake *FakeOpsmanClient) ApplyChangesCalls(stub func(context.Context) error) {
	fake.applyChangesMutex.Lock()
	defer fake.applyChangesMutex.Unlock()
	fake.ApplyChangesStub = stub
}

func (fake *FakeOpsmanClient) ApplyChangesArgsForCall(i int) context.Context {
	fake.applyChangesMutex.RLock()
	defer fake.applyChangesMutex.RUnlock()
	argsForCall := fake.applyChangesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOpsmanClient) ApplyChangesReturns(result1 error) {
	fake.applyChangesMutex.Lock()
	defer fake.applyChangesMutex.Unlock()
	fake.ApplyChangesStub = nil
	fake.applyChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) ApplyChangesReturnsOnCall(i int, result1 error) {
	fake.applyChangesMutex.Lock()
	defer fake.applyChangesMutex.Unlock()
	fake.ApplyChangesStub = nil
	if fake.applyChangesReturnsOnCall == nil {
		fake.applyChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.applyChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) ConfigureAuthentication(arg1 context.Context) error {
	fake.configureAuthenticationMutex.Lock()
	ret, specificReturn := fake.configureAuthenticationReturnsOnCall[len(fake.configureAuthenticationArgsForCall)]
	fake.configureAuthenticationArgsForCall = append(fake.configureAuthenticationArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("ConfigureAuthentication", []interface{}{arg1})
	fake.configureAuthenticationMutex.Unlock()
	if fake.ConfigureAuthenticationStub != nil {
		return fake.ConfigureAuthenticationStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.configureAuthenticationReturns
	return fakeReturns.result1
}

func (fake *FakeOpsmanClient) ConfigureAuthenticationCallCount() int {
	fake.configureAuthenticationMutex.RLock()
	defer fake.configureAuthenticationMutex.RUnlock()
	return len(fake.configureAuthenticationArgsForCall)
}

func (fake *FakeOpsmanClient) ConfigureAuthenticationCalls(stub func(context.Context) error) {
	fake.configureAuthenticationMutex.Lock()
	defer fake.configureAuthenticationMutex.Unlock()
	fake.ConfigureAuthenticationStub = stub
}

func (fake *FakeOpsmanClient) ConfigureAuthenticationArgsForCall(i int) context.Context {
	fake.configureAuthenticationMutex.RLock()
	defer fake.configureAuthenticationMutex.RUnlock()
	argsForCall := fake.configureAuthenticationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOpsmanClient) ConfigureAuthenticationReturns(result1 error) {
	fake.configureAuthenticationMutex.Lock()
	defer fake.configureAuthenticationMutex.Unlock()
	fake.ConfigureAuthenticationStub = nil
	fake.configureAuthenticationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) ConfigureAuthenticationReturnsOnCall(i int, result1 error) {
	fake.configureAuthenticationMutex.Lock()
	defer fake.configureAuthenticationMutex.Unlock()
	fake.ConfigureAuthenticationStub = nil
	if fake.configureAuthenticationReturnsOnCall == nil {
		fake.configureAuthenticationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.configureAuthenticationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) ConfigureDirector(arg1 context.Context, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.configureDirectorMutex.Lock()
	ret, specificReturn := fake.configureDirectorReturnsOnCall[len(fake.configureDirectorArgsForCall)]
	fake.configureDirectorArgsForCall = append(fake.configureDirectorArgsForCall, struct {
		arg1 context.Context
		arg2 []byte
	}{arg1, arg2Copy})
	fake.recordInvocation("ConfigureDirector", []interface{}{arg1, arg2Copy})
	fake.configureDirectorMutex.Unlock()
	if fake.ConfigureDirectorStub != nil {
		return fake.ConfigureDirectorStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.configureDirectorReturns
	return fakeReturns.result1
}

func (fake *FakeOpsmanClient) ConfigureDirectorCallCount() int {
	fake.configureDirectorMutex.RLock()
	defer fake.configureDirectorMutex.RUnlock()
	return len(fake.configureDirectorArgsForCall)
}

func (fake *FakeOpsmanClient) ConfigureDirectorCalls(stub func(context.Context, []byte) error) {
	fake.configureDirectorMutex.Lock()
	defer fake.configureDirectorMutex.Unlock()
	fake.ConfigureDirectorStub = stub
}

func (fake *FakeOpsmanClient) ConfigureDirectorArgsForCall(i int) (context.Context, []byte) {
	fake.configureDirectorMutex.RLock()
	defer fake.configureDirectorMutex.RUnlock()
	argsForCall := fake.configureDirectorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOpsmanClient) ConfigureDirectorReturns(result1 error) {
	fake.configureDirectorMutex.Lock()
	defer fake.configureDirectorMutex.Unlock()
	fake.ConfigureDirectorStub = nil
	fake.configureDirectorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) ConfigureDirectorReturnsOnCall(i int, result1 error) {
	fake.configureDirectorMutex.Lock()
	defer fake.configureDirectorMutex.Unlock()
	fake.ConfigureDirectorStub = nil
	if fake.configureDirectorReturnsOnCall == nil {
		fake.configureDirectorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.configureDirectorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) ConfigureProduct(arg1 context.Context, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.configureProductMutex.Lock()
	ret, specificReturn := fake.configureProductReturnsOnCall[len(fake.configureProductArgsForCall)]
	fake.configureProductArgsForCall = append(fake.configureProductArgsForCall, struct {
		arg1 context.Context
		arg2 []byte
	}{arg1, arg2Copy})
	fake.recordInvocation("ConfigureProduct", []interface{}{arg1, arg2Copy})
	fake.configureProductMutex.Unlock()
	if fake.ConfigureProductStub != nil {
		return fake.ConfigureProductStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.configureProductReturns
	return fakeReturns.result1
}

func (fake *FakeOpsmanClient) ConfigureProductCallCount() int {
	fake.configureProductMutex.RLock()
	defer fake.configureProductMutex.RUnlock()
	return len(fake.configureProductArgsForCall)
}

func (fake *FakeOpsmanClient) ConfigureProductCalls(stub func(context.Context, []byte) error) {
	fake.configureProductMutex.Lock()
	defer fake.configureProductMutex.Unlock()
	fake.ConfigureProductStub = stub
}

func (fake *FakeOpsmanClient) ConfigureProductArgsForCall(i int) (context.Context, []byte) {
	fake.configureProductMutex.RLock()
	defer fake.configureProductMutex.RUnlock()
	argsForCall := fake.configureProductArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOpsmanClient) ConfigureProductReturns(result1 error) {
	fake.configureProductMutex.Lock()
	defer fake.configureProductMutex.Unlock()
	fake.ConfigureProductStub = nil
	fake.configureProductReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) ConfigureProductReturnsOnCall(i int, result1 error) {
	fake.configureProductMutex.Lock()
	defer fake.configureProductMutex.Unlock()
	fake.ConfigureProductStub = nil
	if fake.configureProductReturnsOnCall == nil {
		fake.configureProductReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.configureProductReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) DeleteInstallation(arg1 context.Context) error {
	fake.deleteInstallationMutex.Lock()
	ret, specificReturn := fake.deleteInstallationReturnsOnCall[len(fake.deleteInstallationArgsForCall)]
	fake.deleteInstallationArgsForCall = append(fake.deleteInstallationArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("DeleteInstallation", []interface{}{arg1})
	fake.deleteInstallationMutex.Unlock()
	if fake.DeleteInstallationStub != nil {
		return fake.DeleteInstallationStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteInstallationReturns
	return fakeReturns.result1
}

func (fake *FakeOpsmanClient) DeleteInstallationCallCount() int {
	fake.deleteInstallationMutex.RLock()
	defer fake.deleteInstallationMutex.RUnlock()
	return len(fake.deleteInstallationArgsForCall)
}

func (fake *FakeOpsmanClient) DeleteInstallationCalls(stub func(context.Context) error) {
	fake.deleteInstallationMutex.Lock()
	defer fake.deleteInstallationMutex.Unlock()
	fake.DeleteInstallationStub = stub
}

func (fake *FakeOpsmanClient) DeleteInstallationArgsForCall(i int) context.Context {
	fake.deleteInstallationMutex.RLock()
	defer fake.deleteInstallationMutex.RUnlock()
	argsForCall := fake.deleteInstallationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOpsmanClient) DeleteInstallationReturns(result1 error) {
	fake.deleteInstallationMutex.Lock()
	defer fake.deleteInstallationMutex.Unlock()
	fake.DeleteInstallationStub = nil
	fake.deleteInstallationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) DeleteInstallationReturnsOnCall(i int, result1 error) {
	fake.deleteInstallationMutex.Lock()
	defer fake.deleteInstallationMutex.Unlock()
	fake.DeleteInstallationStub = nil
	if fake.deleteInstallationReturnsOnCall == nil {
		fake.deleteInstallationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteInstallationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) FilesUploaded(arg1 context.Context, arg2 pattern.Tile) (bool, error) {
	fake.filesUploadedMutex.Lock()
	ret, specificReturn := fake.filesUploadedReturnsOnCall[len(fake.filesUploadedArgsForCall)]
	fake.filesUploadedArgsForCall = append(fake.filesUploadedArgsForCall, struct {
		arg1 context.Context
		arg2 pattern.Tile
	}{arg1, arg2})
	fake.recordInvocation("FilesUploaded", []interface{}{arg1, arg2})
	fake.filesUploadedMutex.Unlock()
	if fake.FilesUploadedStub != nil {
		return fake.FilesUploadedStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.filesUploadedReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOpsmanClient) FilesUploadedCallCount() int {
	fake.filesUploadedMutex.RLock()
	defer fake.filesUploadedMutex.RUnlock()
	return len(fake.filesUploadedArgsForCall)
}

func (fake *FakeOpsmanClient) FilesUploadedCalls(stub func(context.Context, pattern.Tile) (bool, error)) {
	fake.filesUploadedMutex.Lock()
	defer fake.filesUploadedMutex.Unlock()
	fake.FilesUploadedStub = stub
}

func (fake *FakeOpsmanClient) FilesUploadedArgsForCall(i int) (context.Context, pattern.Tile) {
	fake.filesUploadedMutex.RLock()
	defer fake.filesUploadedMutex.RUnlock()
	argsForCall := fake.filesUploadedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOpsmanClient) FilesUploadedReturns(result1 bool, result2 error) {
	fake.filesUploadedMutex.Lock()
	defer fake.filesUploadedMutex.Unlock()
	fake.FilesUploadedStub = nil
	fake.filesUploadedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeOpsmanClient) FilesUploadedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.filesUploadedMutex.Lock()
	defer fake.filesUploadedMutex.Unlock()
	fake.FilesUploadedStub = nil
	if fake.filesUploadedReturnsOnCall == nil {
		fake.filesUploadedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.filesUploadedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeOpsmanClient) PollTillOnline(arg1 context.Context) error {
	fake.pollTillOnlineMutex.Lock()
	ret, specificReturn := fake.pollTillOnlineReturnsOnCall[len(fake.pollTillOnlineArgsForCall)]
	fake.pollTillOnlineArgsForCall = append(fake.pollTillOnlineArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("PollTillOnline", []interface{}{arg1})
	fake.pollTillOnlineMutex.Unlock()
	if fake.PollTillOnlineStub != nil {
		return fake.PollTillOnlineStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pollTillOnlineReturns
	return fakeReturns.result1
}

func (fake *FakeOpsmanClient) PollTillOnlineCallCount() int {
	fake.pollTillOnlineMutex.RLock()
	defer fake.pollTillOnlineMutex.RUnlock()
	return len(fake.pollTillOnlineArgsForCall)
}

func (fake *FakeOpsmanClient) PollTillOnlineCalls(stub func(context.Context) error) {
	fake.pollTillOnlineMutex.Lock()
	defer fake.pollTillOnlineMutex.Unlock()
	fake.PollTillOnlineStub = stub
}

func (fake *FakeOpsmanClient) PollTillOnlineArgsForCall(i int) context.Context {
	fake.pollTillOnlineMutex.RLock()
	defer fake.pollTillOnlineMutex.RUnlock()
	argsForCall := fake.pollTillOnlineArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOpsmanClient) PollTillOnlineReturns(result1 error) {
	fake.pollTillOnlineMutex.Lock()
	defer fake.pollTillOnlineMutex.Unlock()
	fake.PollTillOnlineStub = nil
	fake.pollTillOnlineReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) PollTillOnlineReturnsOnCall(i int, result1 error) {
	fake.pollTillOnlineMutex.Lock()
	defer fake.pollTillOnlineMutex.Unlock()
	fake.PollTillOnlineStub = nil
	if fake.pollTillOnlineReturnsOnCall == nil {
		fake.pollTillOnlineReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pollTillOnlineReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) StageProduct(arg1 context.Context, arg2 pattern.Tile) error {
	fake.stageProductMutex.Lock()
	ret, specificReturn := fake.stageProductReturnsOnCall[len(fake.stageProductArgsForCall)]
	fake.stageProductArgsForCall = append(fake.stageProductArgsForCall, struct {
		arg1 context.Context
		arg2 pattern.Tile
	}{arg1, arg2})
	fake.recordInvocation("StageProduct", []interface{}{arg1, arg2})
	fake.stageProductMutex.Unlock()
	if fake.StageProductStub != nil {
		return fake.StageProductStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.stageProductReturns
	return fakeReturns.result1
}

func (fake *FakeOpsmanClient) StageProductCallCount() int {
	fake.stageProductMutex.RLock()
	defer fake.stageProductMutex.RUnlock()
	return len(fake.stageProductArgsForCall)
}

func (fake *FakeOpsmanClient) StageProductCalls(stub func(context.Context, pattern.Tile) error) {
	fake.stageProductMutex.Lock()
	defer fake.stageProductMutex.Unlock()
	fake.StageProductStub = stub
}

func (fake *FakeOpsmanClient) StageProductArgsForCall(i int) (context.Context, pattern.Tile) {
	fake.stageProductMutex.RLock()
	defer fake.stageProductMutex.RUnlock()
	argsForCall := fake.stageProductArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOpsmanClient) StageProductReturns(result1 error) {
	fake.stageProductMutex.Lock()
	defer fake.stageProductMutex.Unlock()
	fake.StageProductStub = nil
	fake.stageProductReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) StageProductReturnsOnCall(i int, result1 error) {
	fake.stageProductMutex.Lock()
	defer fake.stageProductMutex.Unlock()
	fake.StageProductStub = nil
	if fake.stageProductReturnsOnCall == nil {
		fake.stageProductReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stageProductReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) UploadProduct(arg1 context.Context, arg2 *os.File) error {
	fake.uploadProductMutex.Lock()
	ret, specificReturn := fake.uploadProductReturnsOnCall[len(fake.uploadProductArgsForCall)]
	fake.uploadProductArgsForCall = append(fake.uploadProductArgsForCall, struct {
		arg1 context.Context
		arg2 *os.File
	}{arg1, arg2})
	fake.recordInvocation("UploadProduct", []interface{}{arg1, arg2})
	fake.uploadProductMutex.Unlock()
	if fake.UploadProductStub != nil {
		return fake.UploadProductStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uploadProductReturns
	return fakeReturns.result1
}

func (fake *FakeOpsmanClient) UploadProductCallCount() int {
	fake.uploadProductMutex.RLock()
	defer fake.uploadProductMutex.RUnlock()
	return len(fake.uploadProductArgsForCall)
}

func (fake *FakeOpsmanClient) UploadProductCalls(stub func(context.Context, *os.File) error) {
	fake.uploadProductMutex.Lock()
	defer fake.uploadProductMutex.Unlock()
	fake.UploadProductStub = stub
}

func (fake *FakeOpsmanClient) UploadProductArgsForCall(i int) (context.Context, *os.File) {
	fake.uploadProductMutex.RLock()
	defer fake.uploadProductMutex.RUnlock()
	argsForCall := fake.uploadProductArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOpsmanClient) UploadProductReturns(result1 error) {
	fake.uploadProductMutex.Lock()
	defer fake.uploadProductMutex.Unlock()
	fake.UploadProductStub = nil
	fake.uploadProductReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) UploadProductReturnsOnCall(i int, result1 error) {
	fake.uploadProductMutex.Lock()
	defer fake.uploadProductMutex.Unlock()
	fake.UploadProductStub = nil
	if fake.uploadProductReturnsOnCall == nil {
		fake.uploadProductReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadProductReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) UploadStemcell(arg1 context.Context, arg2 *os.File) error {
	fake.uploadStemcellMutex.Lock()
	ret, specificReturn := fake.uploadStemcellReturnsOnCall[len(fake.uploadStemcellArgsForCall)]
	fake.uploadStemcellArgsForCall = append(fake.uploadStemcellArgsForCall, struct {
		arg1 context.Context
		arg2 *os.File
	}{arg1, arg2})
	fake.recordInvocation("UploadStemcell", []interface{}{arg1, arg2})
	fake.uploadStemcellMutex.Unlock()
	if fake.UploadStemcellStub != nil {
		return fake.UploadStemcellStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uploadStemcellReturns
	return fakeReturns.result1
}

func (fake *FakeOpsmanClient) UploadStemcellCallCount() int {
	fake.uploadStemcellMutex.RLock()
	defer fake.uploadStemcellMutex.RUnlock()
	return len(fake.uploadStemcellArgsForCall)
}

func (fake *FakeOpsmanClient) UploadStemcellCalls(stub func(context.Context, *os.File) error) {
	fake.uploadStemcellMutex.Lock()
	defer fake.uploadStemcellMutex.Unlock()
	fake.UploadStemcellStub = stub
}

func (fake *FakeOpsmanClient) UploadStemcellArgsForCall(i int) (context.Context, *os.File) {
	fake.uploadStemcellMutex.RLock()
	defer fake.uploadStemcellMutex.RUnlock()
	argsForCall := fake.uploadStemcellArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOpsmanClient) UploadStemcellReturns(result1 error) {
	fake.uploadStemcellMutex.Lock()
	defer fake.uploadStemcellMutex.Unlock()
	fake.UploadStemcellStub = nil
	fake.uploadStemcellReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) UploadStemcellReturnsOnCall(i int, result1 error) {
	fake.uploadStemcellMutex.Lock()
	defer fake.uploadStemcellMutex.Unlock()
	fake.UploadStemcellStub = nil
	if fake.uploadStemcellReturnsOnCall == nil {
		fake.uploadStemcellReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadStemcellReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOpsmanClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.applyChangesMutex.RLock()
	defer fake.applyChangesMutex.RUnlock()
	fake.configureAuthenticationMutex.RLock()
	defer fake.configureAuthenticationMutex.RUnlock()
	fake.configureDirectorMutex.RLock()
	defer fake.configureDirectorMutex.RUnlock()
	fake.configureProductMutex.RLock()
	defer fake.configureProductMutex.RUnlock()
	fake.deleteInstallationMutex.RLock()
	defer fake.deleteInstallationMutex.RUnlock()
	fake.filesUploadedMutex.RLock()
	defer fake.filesUploadedMutex.RUnlock()
	fake.pollTillOnlineMutex.RLock()
	defer fake.pollTillOnlineMutex.RUnlock()
	fake.stageProductMutex.RLock()
	defer fake.stageProductMutex.RUnlock()
	fake.uploadProductMutex.RLock()
	defer fake.uploadProductMutex.RUnlock()
	fake.uploadStemcellMutex.RLock()
	defer fake.uploadStemcellMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeOpsmanClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ tiler.OpsmanClient = new(FakeOpsmanClient)
